<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatX</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #5865F2;
            --dark: #2C2F33;
            --darker: #23272A;
            --light: #FFFFFF;
            --gray: #99AAB5;
            --success: #3BA55C;
            --danger: #ED4245;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Roboto', sans-serif;
        }

        body {
            display: flex;
            height: 100vh;
            background-color: var(--dark);
            color: var(--light);
        }

        /* Server/Group sidebar */
        .servers {
            width: 72px;
            background-color: var(--darker);
            padding: 12px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .server-icon {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: var(--gray);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .server-icon:hover {
            border-radius: 16px;
            background-color: var(--primary);
        }

        .server-icon.active {
            background-color: var(--primary);
            border-radius: 16px;
        }

        /* Channels sidebar */
        .channels {
            width: 240px;
            background-color: var(--darker);
            display: flex;
            flex-direction: column;
        }

        .channel-header {
            padding: 16px;
            border-bottom: 1px solid rgba(0,0,0,0.2);
            font-weight: 700;
            display: flex;
            justify-content: space-between;
        }

        .channel-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
        }

        .channel {
            padding: 8px 16px;
            margin: 0 8px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .channel:hover {
            background-color: rgba(255,255,255,0.1);
        }

        .channel.active {
            background-color: rgba(255,255,255,0.2);
        }

        /* Main chat area */
        .chat {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .message {
            display: flex;
            gap: 16px;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            flex-shrink: 0;
        }

        .message-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .username {
            font-weight: 500;
        }

        .timestamp {
            color: var(--gray);
            font-size: 0.75rem;
        }

        .message-text {
            line-height: 1.4;
        }

        .system-message {
            color: var(--gray);
            font-size: 0.9rem;
            width: 100%;
            text-align: center;
            padding: 8px 0;
        }

        /* Input area */
        .input-area {
            padding: 16px;
            background-color: var(--darker);
        }

        .message-input {
            width: 100%;
            padding: 12px 16px;
            background-color: rgba(0,0,0,0.2);
            border: none;
            border-radius: 8px;
            color: var(--light);
            font-size: 1rem;
            outline: none;
        }

        /* Members sidebar */
        .members {
            width: 240px;
            background-color: var(--darker);
            padding: 16px;
            overflow-y: auto;
        }

        .member {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 0;
        }

        .member-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
        }

        .member-voice {
            margin-left: auto;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--success);
            display: none;
        }

        .member-voice.active {
            display: block;
        }

        /* Voice chat UI */
        .voice-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--darker);
            padding: 12px 24px;
            border-radius: 8px;
            display: flex;
            gap: 16px;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10;
        }

        .voice-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--danger);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .voice-btn:hover {
            transform: scale(1.1);
        }

        .voice-btn.muted {
            background-color: var(--gray);
        }

        /* Modals */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .modal-content {
            background-color: var(--darker);
            padding: 24px;
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
        }

        .modal-title {
            margin-bottom: 16px;
            font-size: 1.25rem;
            font-weight: 700;
        }

        .modal-input {
            width: 100%;
            padding: 12px 16px;
            background-color: rgba(0,0,0,0.2);
            border: none;
            border-radius: 4px;
            color: var(--light);
            margin-bottom: 16px;
            outline: none;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .modal-btn {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }

        .modal-btn.primary {
            background-color: var(--primary);
            color: white;
        }

        .modal-btn.secondary {
            background-color: transparent;
            color: var(--gray);
        }

        /* Voice channel indicator */
        .voice-indicator {
            display: none;
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--darker);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            z-index: 10;
        }

        .voice-indicator.active {
            display: block;
        }

        /* Request modal */
        .request-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        .request-content {
            background-color: var(--darker);
            padding: 24px;
            border-radius: 8px;
            width: 350px;
            max-width: 90%;
        }
        
        .request-title {
            margin-bottom: 16px;
            font-size: 1.1rem;
            font-weight: 500;
        }
        
        .request-text {
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        .request-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        
        .request-btn {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }
        
        .request-btn.accept {
            background-color: var(--success);
            color: white;
        }
        
        .request-btn.decline {
            background-color: var(--danger);
            color: white;
        }
    </style>
</head>
<body>
    <!-- Servers sidebar - now just has group management button -->
    <div class="servers">
        <div class="server-icon" id="group-management-btn">+</div>
    </div>

    <!-- Channels sidebar -->
    <div class="channels">
        <div class="channel-header">
            <span>General</span>
            <span>+</span>
        </div>
        <div class="channel-list">
            <div class="channel active" data-channel="text"># text-chat</div>
            <div class="channel" data-channel="voice"># voice-chat</div>
            <div class="channel"># announcements</div>
        </div>
    </div>

    <!-- Main chat area -->
    <div class="chat">
        <div class="messages" id="messages">
            <!-- Messages will be added here -->
        </div>
        <div class="input-area">
            <input type="text" class="message-input" id="message-input" placeholder="Message #text-chat">
        </div>
    </div>

    <!-- Members sidebar -->
    <div class="members" id="members-list">
        <!-- Members will be added dynamically -->
    </div>

    <!-- Voice controls -->
    <div class="voice-controls" id="voice-controls" style="display: none;">
        <div class="voice-btn" id="mute-btn">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" y1="19" x2="12" y2="23"></line>
                <line x1="8" y1="23" x2="16" y2="23"></line>
            </svg>
        </div>
        <div class="voice-btn" id="leave-btn">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M10 3H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h4"></path>
                <path d="M16 17l5-5-5-5"></path>
                <line x1="21" y1="12" x2="10" y2="12"></line>
            </svg>
        </div>
    </div>

    <!-- Voice channel indicator -->
    <div class="voice-indicator" id="voice-indicator">
        You're in a voice channel
    </div>

    <!-- Username modal -->
    <div class="modal" id="username-modal">
        <div class="modal-content">
            <div class="modal-title">Enter Your Username</div>
            <input type="text" class="modal-input" id="username-input" placeholder="Username">
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="cancel-username">Cancel</button>
                <button class="modal-btn primary" id="save-username">Continue</button>
            </div>
        </div>
    </div>

    <!-- Group modal -->
    <div class="modal" id="group-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-title">Create or Join Group</div>
            <input type="text" class="modal-input" id="group-id-input" placeholder="Group ID">
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="cancel-group">Cancel</button>
                <button class="modal-btn primary" id="join-group">Join</button>
                <button class="modal-btn primary" id="create-group">Create</button>
            </div>
        </div>
    </div>

    <!-- Voice Request Modal -->
    <div class="request-modal" id="voice-request-modal" style="display: none;">
        <div class="request-content">
            <div class="request-title">Voice Chat Request</div>
            <div class="request-text" id="voice-request-text">
                User wants you to join voice chat. Accept to connect your microphone.
            </div>
            <div class="request-buttons">
                <button class="request-btn decline" id="decline-voice">Decline</button>
                <button class="request-btn accept" id="accept-voice">Accept</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        // App state
        const state = {
            username: '',
            currentGroup: null,
            peer: null,
            connections: [],
            localStream: null,
            audioContext: null,
            voiceConnections: {},
            currentChannel: 'text',
            members: [],
            peerUsernames: {},
            remoteAudioElements: {},
            voiceRequestFrom: null,
            pendingVoiceRequest: null
        };

        // DOM elements
        const elements = {
            messages: document.getElementById('messages'),
            messageInput: document.getElementById('message-input'),
            voiceControls: document.getElementById('voice-controls'),
            muteBtn: document.getElementById('mute-btn'),
            leaveBtn: document.getElementById('leave-btn'),
            usernameModal: document.getElementById('username-modal'),
            usernameInput: document.getElementById('username-input'),
            saveUsername: document.getElementById('save-username'),
            cancelUsername: document.getElementById('cancel-username'),
            groupModal: document.getElementById('group-modal'),
            groupIdInput: document.getElementById('group-id-input'),
            joinGroup: document.getElementById('join-group'),
            createGroup: document.getElementById('create-group'),
            cancelGroup: document.getElementById('cancel-group'),
            membersList: document.getElementById('members-list'),
            voiceIndicator: document.getElementById('voice-indicator'),
            channels: document.querySelectorAll('.channel'),
            groupManagementBtn: document.getElementById('group-management-btn'),
            voiceRequestModal: document.getElementById('voice-request-modal'),
            voiceRequestText: document.getElementById('voice-request-text'),
            acceptVoice: document.getElementById('accept-voice'),
            declineVoice: document.getElementById('decline-voice')
        };

        // Initialize PeerJS
        function initPeer() {
            state.peer = new Peer({
                host: '0.peerjs.com',
                port: 443,
                path: '/',
                debug: 3
            });

            state.peer.on('open', (id) => {
                console.log('Peer connected with ID:', id);
                // Add yourself to members list
                addMember(state.username, state.peer.id);
                state.peerUsernames[state.peer.id] = state.username;
            });

            state.peer.on('connection', (conn) => {
                setupConnection(conn);
            });

            state.peer.on('error', (err) => {
                console.error('Peer error:', err);
            });
        }

        // Setup data connection
        function setupConnection(conn) {
            state.connections.push(conn);

            conn.on('open', () => {
                // Send username to peer
                conn.send({
                    type: 'user-join',
                    username: state.username,
                    userId: state.peer.id
                });

                // Store the peer's username from their metadata
                if (conn.metadata && conn.metadata.username) {
                    state.peerUsernames[conn.peer] = conn.metadata.username;
                    addMessage(`${conn.metadata.username} joined the group`, 'system');
                    addMember(conn.metadata.username, conn.peer);
                }
            });

            conn.on('data', (data) => {
                handleIncomingData(conn, data);
            });

            conn.on('close', () => {
                const username = state.peerUsernames[conn.peer] || conn.peer;
                addMessage(`${username} left the group`, 'system');
                state.connections = state.connections.filter(c => c !== conn);
                removeMember(conn.peer);
                delete state.peerUsernames[conn.peer];
                
                // Clean up voice connection if it exists
                if (state.voiceConnections[conn.peer]) {
                    state.voiceConnections[conn.peer].close();
                    delete state.voiceConnections[conn.peer];
                }
                
                // Clean up audio element if it exists
                if (state.remoteAudioElements[conn.peer]) {
                    state.remoteAudioElements[conn.peer].remove();
                    delete state.remoteAudioElements[conn.peer];
                }
            });

            conn.on('error', (err) => {
                console.error('Connection error:', err);
            });
        }

        // Handle incoming data
        function handleIncomingData(conn, data) {
            switch (data.type) {
                case 'user-join':
                    // Store the username with the peer ID
                    state.peerUsernames[data.userId] = data.username;
                    addMessage(`${data.username} joined the group`, 'system');
                    addMember(data.username, data.userId);
                    break;
                case 'message':
                    if (data.channel === state.currentChannel) {
                        // Get the correct username from our mapping
                        const senderUsername = state.peerUsernames[conn.peer] || conn.peer;
                        addMessage(data.text, 'remote', senderUsername);
                    }
                    break;
                case 'voice-offer':
                    handleVoiceOffer(conn, data);
                    break;
                case 'voice-answer':
                    handleVoiceAnswer(conn, data);
                    break;
                case 'voice-candidate':
                    handleVoiceCandidate(conn, data);
                    break;
                case 'voice-state':
                    updateMemberVoiceState(data.userId, data.inVoice);
                    break;
                case 'voice-request':
                    handleVoiceRequest(conn, data);
                    break;
                case 'voice-response':
                    handleVoiceResponse(conn, data);
                    break;
            }
        }

        // Voice chat functions
        async function initVoiceChat() {
            try {
                // Get microphone access with specific constraints for continuous transmission
                state.localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                elements.voiceControls.style.display = 'flex';
                elements.voiceIndicator.classList.add('active');
                
                // Notify others that we joined voice
                state.connections.forEach(conn => {
                    conn.send({
                        type: 'voice-state',
                        userId: state.peer.id,
                        inVoice: true
                    });
                });
                
                // Update local member state
                updateMemberVoiceState(state.peer.id, true);
                
                // Automatically connect to all peers in voice channel
                startVoiceChat();
            } catch (err) {
                console.error('Error accessing microphone:', err);
                addMessage('Failed to access microphone. Please check permissions.', 'system');
            }
        }

        async function startVoiceChat() {
            if (state.currentChannel !== 'voice') return;
            
            if (!state.localStream) {
                await initVoiceChat();
                return;
            }
            
            // Connect to all peers in the group
            state.connections.forEach(conn => {
                if (!state.voiceConnections[conn.peer]) {
                    createPeerConnection(conn);
                }
            });
        }

        async function createPeerConnection(conn) {
            if (!state.localStream) return;
            
            const peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            state.voiceConnections[conn.peer] = peerConnection;

            // Add local stream - always add track for continuous transmission
            state.localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, state.localStream);
            });

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    conn.send({
                        type: 'voice-candidate',
                        candidate: event.candidate
                    });
                }
            };

            // Handle remote stream
            peerConnection.ontrack = (event) => {
                // Create or reuse audio element for this peer
                if (!state.remoteAudioElements[conn.peer]) {
                    const audio = document.createElement('audio');
                    audio.autoplay = true;
                    audio.controls = false;
                    audio.style.display = 'none';
                    document.body.appendChild(audio);
                    state.remoteAudioElements[conn.peer] = audio;
                }
                
                // Update the audio stream
                state.remoteAudioElements[conn.peer].srcObject = event.streams[0];
            };

            // Create offer
            const offer = await peerConnection.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: false
            });
            
            // Set up continuous ice gathering
            peerConnection.onnegotiationneeded = async () => {
                try {
                    const newOffer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(newOffer);
                    conn.send({
                        type: 'voice-offer',
                        offer: peerConnection.localDescription
                    });
                } catch (err) {
                    console.error('Error in renegotiation:', err);
                }
            };

            await peerConnection.setLocalDescription(offer);

            conn.send({
                type: 'voice-offer',
                offer: offer
            });
        }

        async function handleVoiceOffer(conn, data) {
            if (!state.localStream) await initVoiceChat();
            
            const peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            state.voiceConnections[conn.peer] = peerConnection;

            // Add local stream - always add track for continuous transmission
            state.localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, state.localStream);
            });

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    conn.send({
                        type: 'voice-candidate',
                        candidate: event.candidate
                    });
                }
            };

            // Handle remote stream
            peerConnection.ontrack = (event) => {
                // Create or reuse audio element for this peer
                if (!state.remoteAudioElements[conn.peer]) {
                    const audio = document.createElement('audio');
                    audio.autoplay = true;
                    audio.controls = false;
                    audio.style.display = 'none';
                    document.body.appendChild(audio);
                    state.remoteAudioElements[conn.peer] = audio;
                }
                
                // Update the audio stream
                state.remoteAudioElements[conn.peer].srcObject = event.streams[0];
            };

            // Set remote description and create answer
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            conn.send({
                type: 'voice-answer',
                answer: answer
            });
        }

        async function handleVoiceAnswer(conn, data) {
            const peerConnection = state.voiceConnections[conn.peer];
            if (!peerConnection) return;
            
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        }

        async function handleVoiceCandidate(conn, data) {
            const peerConnection = state.voiceConnections[conn.peer];
            if (!peerConnection) return;
            
            try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            } catch (err) {
                console.error('Error adding ICE candidate:', err);
            }
        }

        function leaveVoiceChat() {
            if (state.localStream) {
                state.localStream.getTracks().forEach(track => track.stop());
                state.localStream = null;
            }
            
            // Close all peer connections
            Object.values(state.voiceConnections).forEach(pc => pc.close());
            state.voiceConnections = {};
            
            // Remove all remote audio elements
            Object.values(state.remoteAudioElements).forEach(audio => audio.remove());
            state.remoteAudioElements = {};
            
            elements.voiceControls.style.display = 'none';
            elements.voiceIndicator.classList.remove('active');
            
            // Notify others that we left voice
            state.connections.forEach(conn => {
                conn.send({
                    type: 'voice-state',
                    userId: state.peer.id,
                    inVoice: false
                });
            });
            
            // Update local member state
            updateMemberVoiceState(state.peer.id, false);
        }

        // Voice request functions
        function handleVoiceRequest(conn, data) {
            // Only show request if we're not already in voice chat
            if (!state.localStream) {
                state.voiceRequestFrom = conn.peer;
                state.pendingVoiceRequest = data;
                
                const username = state.peerUsernames[conn.peer] || conn.peer;
                elements.voiceRequestText.textContent = `${username} wants you to join voice chat. Accept to connect your microphone.`;
                elements.voiceRequestModal.style.display = 'flex';
            }
        }

        function handleVoiceResponse(conn, data) {
            if (data.accepted) {
                // If accepted, start voice chat
                startVoiceChat();
            } else {
                addMessage(`${state.peerUsernames[conn.peer] || conn.peer} declined your voice chat request`, 'system');
            }
        }

        function sendVoiceRequest() {
            if (state.connections.length === 0) {
                addMessage('No one is in the group to request voice chat with', 'system');
                return;
            }
            
            // Send request to all connections
            state.connections.forEach(conn => {
                conn.send({
                    type: 'voice-request',
                    from: state.peer.id,
                    username: state.username
                });
            });
            
            addMessage('Sent voice chat requests to all group members', 'system');
        }

        // UI functions
        function addMessage(text, type = 'local', username = state.username) {
            const messageElement = document.createElement('div');
            messageElement.className = 'message';
            
            if (type === 'system') {
                messageElement.innerHTML = `
                    <div class="system-message">${text}</div>
                `;
            } else {
                const avatarText = username.substring(0, 2).toUpperCase();
                messageElement.innerHTML = `
                    <div class="avatar">${avatarText}</div>
                    <div class="message-content">
                        <div class="message-header">
                            <span class="username">${username}</span>
                            <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                        </div>
                        <div class="message-text">${text}</div>
                    </div>
                `;
                
                if (type === 'local') {
                    messageElement.querySelector('.avatar').style.backgroundColor = '#ED4245';
                }
            }
            
            elements.messages.appendChild(messageElement);
            elements.messages.scrollTop = elements.messages.scrollHeight;
        }

        function addMember(username, userId) {
            // Check if member already exists
            if (state.members.some(m => m.id === userId)) return;
            
            const member = {
                id: userId,
                username: username,
                inVoice: false
            };
            state.members.push(member);
            renderMembers();
        }

        function removeMember(userId) {
            state.members = state.members.filter(m => m.id !== userId);
            renderMembers();
        }

        function updateMemberVoiceState(userId, inVoice) {
            const member = state.members.find(m => m.id === userId);
            if (member) {
                member.inVoice = inVoice;
                renderMembers();
            }
        }

        function renderMembers() {
            elements.membersList.innerHTML = '';
            
            state.members.forEach(member => {
                const memberElement = document.createElement('div');
                memberElement.className = 'member';
                
                const avatarText = member.username.substring(0, 2).toUpperCase();
                memberElement.innerHTML = `
                    <div class="member-avatar">${avatarText}</div>
                    <span>${member.username}</span>
                    <div class="member-voice ${member.inVoice ? 'active' : ''}"></div>
                `;
                
                elements.membersList.appendChild(memberElement);
            });
        }

        function showUsernameModal() {
            elements.usernameModal.style.display = 'flex';
        }

        function hideUsernameModal() {
            elements.usernameModal.style.display = 'none';
        }

        function showGroupModal() {
            elements.groupModal.style.display = 'flex';
        }

        function hideGroupModal() {
            elements.groupModal.style.display = 'none';
        }

        function switchChannel(channel) {
            state.currentChannel = channel;
            
            // Update UI
            elements.channels.forEach(c => {
                if (c.dataset.channel === channel) {
                    c.classList.add('active');
                } else {
                    c.classList.remove('active');
                }
            });
            
            // Update input placeholder
            elements.messageInput.placeholder = `Message #${channel}-chat`;
            
            // Handle voice channel
            if (channel === 'voice') {
                // Instead of automatically starting, send requests
                sendVoiceRequest();
            } else if (state.currentChannel === 'voice') {
                leaveVoiceChat();
            }
        }

        // Event listeners
        elements.saveUsername.addEventListener('click', () => {
            const username = elements.usernameInput.value.trim();
            if (username) {
                state.username = username;
                hideUsernameModal();
                initPeer();
            }
        });

        elements.cancelUsername.addEventListener('click', hideUsernameModal);

        elements.joinGroup.addEventListener('click', () => {
            const groupId = elements.groupIdInput.value.trim();
            if (groupId) {
                state.currentGroup = groupId;
                hideGroupModal();
                
                // Connect to group host
                const conn = state.peer.connect(groupId, {
                    metadata: {
                        username: state.username,
                        userId: state.peer.id
                    }
                });
                
                setupConnection(conn);
                addMessage(`Joined group ${groupId}`, 'system');
            }
        });

        elements.createGroup.addEventListener('click', () => {
            state.currentGroup = state.peer.id;
            hideGroupModal();
            addMessage(`Created group ${state.peer.id}`, 'system');
            addMessage('Share this ID with others to join:', 'system');
            addMessage(state.peer.id, 'system');
        });

        elements.cancelGroup.addEventListener('click', hideGroupModal);

        elements.messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && elements.messageInput.value.trim()) {
                const message = elements.messageInput.value.trim();
                addMessage(message, 'local');
                
                // Send to all connections
                state.connections.forEach(conn => {
                    conn.send({
                        type: 'message',
                        text: message,
                        channel: state.currentChannel
                    });
                });
                
                elements.messageInput.value = '';
            }
        });

        elements.muteBtn.addEventListener('click', () => {
            if (state.localStream) {
                const audioTracks = state.localStream.getAudioTracks();
                audioTracks.forEach(track => {
                    track.enabled = !track.enabled;
                });
                elements.muteBtn.classList.toggle('muted');
            }
        });

        elements.leaveBtn.addEventListener('click', leaveVoiceChat);

        // Channel switching
        elements.channels.forEach(channel => {
            channel.addEventListener('click', () => {
                const channelType = channel.dataset.channel;
                if (channelType) {
                    switchChannel(channelType);
                }
            });
        });

        // Group management button
        elements.groupManagementBtn.addEventListener('click', () => {
            if (state.peer) {
                showGroupModal();
            } else {
                addMessage('Please set your username first', 'system');
            }
        });

        // Voice request buttons
        elements.acceptVoice.addEventListener('click', async () => {
            elements.voiceRequestModal.style.display = 'none';
            
            // Accept the request and initialize voice chat
            const conn = state.connections.find(c => c.peer === state.voiceRequestFrom);
            if (conn) {
                conn.send({
                    type: 'voice-response',
                    accepted: true,
                    from: state.peer.id
                });
                
                // Switch to voice channel and start
                switchChannel('voice');
            }
            
            state.voiceRequestFrom = null;
            state.pendingVoiceRequest = null;
        });

        elements.declineVoice.addEventListener('click', () => {
            elements.voiceRequestModal.style.display = 'none';
            
            // Decline the request
            const conn = state.connections.find(c => c.peer === state.voiceRequestFrom);
            if (conn) {
                conn.send({
                    type: 'voice-response',
                    accepted: false,
                    from: state.peer.id
                });
            }
            
            state.voiceRequestFrom = null;
            state.pendingVoiceRequest = null;
        });

        // Initialize
        showUsernameModal();
    </script>
</body>
</html>